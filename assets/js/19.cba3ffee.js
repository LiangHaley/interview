(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{434:function(e,t,n){"use strict";n.r(t);var a=n(1),r=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("这一章节主要学习Vue3相关内容")]),e._v(" "),t("h3",{attrs:{id:"composition-选项式api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composition-选项式api"}},[e._v("#")]),e._v(" Composition 选项式api")]),e._v(" "),t("p",[e._v("写法:script 添加 stepup 指定选项式api\n内置 defineProps({}) 接收父组件传入的参数")]),e._v(" "),t("h3",{attrs:{id:"ref-和-reactive-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-和-reactive-区别"}},[e._v("#")]),e._v(" ref 和 reactive 区别？")]),e._v(" "),t("p",[e._v("ref 声明响应式数据 ref.value自动解包  赋值为字符串 数字简单数据类型\nreactive 监听对象")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export const toReactive =<T extends unknown>(value:T):T => isObject(value):reactive(value):value\nref(obj) === reactive({value:obj})\n")])])]),t("h3",{attrs:{id:"ref-和-shallowref-的区别-以及-reactive-和-shallowreactive-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-和-shallowref-的区别-以及-reactive-和-shallowreactive-的区别"}},[e._v("#")]),e._v(" ref 和 shallowRef 的区别，以及 reactive 和 shallowReactive 的区别？")]),e._v(" "),t("p",[e._v("shallowRef 只监听第一层 即.value,不过我们可以使用triggerRef(xxx),在深层内容变更后，手动触发更新，需要注意的是shallowReactive 没有对应的方法")]),e._v(" "),t("h3",{attrs:{id:"watcheffect-与-watch-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watcheffect-与-watch-的区别"}},[e._v("#")]),e._v(" watchEffect 与 watch 的区别")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("watch 和 watchEffect 都能监听响应式数据的变化，\n不同的是 watch 会明确监听某一个响应式数据的变化，而watchEffect则是隐士的监听回调函数中的响应式数据\nwatch 在响应数据初始化是不会执行回调函数的，watchEffect在响应式数据初始化时就会立即执行回调函数\nflush: 'post' 响应式更新watch 或 watchEffect 下dom 元素的值\nwatchEffect、watchPostEffect、watchSyncEffect 后两者是前者的语法糖，就是将第二个参数中的 flush，指定为对应值，分别为：flush?: 'pre' | 'post' | 'sync' // 默认：'pre'\n")])])]),t("p",[e._v("defineAsyncComponent 异步引入 打包时单独被打包\n安装 rollup-plugin-visualizer 进行打包产物分析")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst AdminPage = defineAsyncComponent(() =>\n  import('./components/AdminPageComponent.vue')\n)\n<\/script>\n\n<template>\n  <AdminPage />\n</template>\n")])])]),t("h3",{attrs:{id:"ref-源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-源码解析"}},[e._v("#")]),e._v(" ref 源码解析")]),e._v(" "),t("p",[e._v("Object.prototype.toString.call(c).slice(8, -1);  判断数据类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("********createReactiveObject*********************\nimport {ref} from 'vue'\nconst num = ref(0)//定义基本的数据类型\n//调用vue 中ref 文件 \nfunction ref(value) {\n    return createRef(value, false);\n}\n// 通过isRef函数来判断所定义的值是否已经是一个ref对象，如果是就直接返回该值。否则实例化RefImpl类，给该值赋予各个关于ref的属性，将其转化为一个ref对象\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) { \n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\n\nfunction isRef(r) {\n/*判断该值的__v_isRef属性是否为true,因为前面r=0,并没有所谓__v_isRef属性，所以这里r.__v_isRef是为undefined。这里的返回值是为false\n*/\n    return !!(r && r.__v_isRef === true);\n}\n//RefImpl的构造器接收两个值，一个value所定义的原始值，一个__v_isShallow是否为浅层响应式\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n    //是否为浅层响应式\n        this.__v_isShallow = __v_isShallow; //传false\n    //dep 是一个 Set 类型的数据，它的作用是用来存储当前的 ref 值收集的依赖\n        this.dep = undefined;\n    //前面说到这个属性用来判断是否转化为ref对象\n        this.__v_isRef = true;\n    //用于保存当前 ref 值对应的原始值，当传递的参数是基本数据类型时，_value 和 _rawValue 相同。如果传递的参数是一个对象的话，_rawValue 用于保存转化前的原始值。\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n    //用于保存 ref 当前的值，如果传递的参数是基本数据类型的话，_value 和 _rawValue 相同。如果传递的参数是一个对象的话，_value 就是经过 reactive 函数转化过的值。\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    //当我们使用 .value 读取属性的时候，会执行 get value(){} 函数，并将函数的返回值作为 .value 读取到的值\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    //在 set value() {} 函数中，判断新值和旧值有没有发生改变，如果有变化的是，则重新赋值 _rawValue 和 _value 属性，并触发当前 ref 值的依赖重新执行。\n    set value(newVal) {\n    //判断原始值是否为浅层响应式或是否为readonly对象\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    //如果该值不是响应式或readonly对象，则返回原来的值，否则将该值通过toRaw转化为原来的target对象\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        //检测两个值是否相等，如果不同了就赋值为新的\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n        //原始值如果为响应式则直接返回，否则将其转化为响应式\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n        //触发依赖，更新视图\n            triggerRefValue(this, newVal);\n        }\n    }\n}\n关于get value(){}的有关函数\nfunction trackRefValue(ref) {\n    // 判断是否需要收集依赖\n    // shouldTrack 全局变量，代表当前是否需要 track 收集依赖\n    // activeEffect 全局变量，代表当前的副作用对象 ReactiveEffect\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n    // 如果没有 dep 属性，则初始化 dep，dep 是一个 Set<ReactiveEffect>，存储副作用函数\n    // trackEffects 收集依赖\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        } else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);//判断原始值是否为浅层响应式\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);//判断原始值是否为只读\n}\n\nfunction reactive(target) {\n    //如果该对象是只读的，就直接返回\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n\n/*createReactiveObject接收五个参数：\ntarget被代理的对象，\nisReadonl是不是只读的，\nbaseHandlers proxy的捕获器，\ncollectionHandlers针对集合的proxy捕获器，\nproxyMap一个用于缓存proxy的`WeakMap`对象*/\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n//如果target不是对象则提示并返回\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // 如果target已经是proxy是代理对象则直接返回.\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // 从proxyMap中获取缓存的proxy对象，如果存在的话，直接返回proxyMap中对应的proxy。否则创建proxy。\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // 并不是任何对象都可以被proxy所代理。这里会通过getTargetType方法来进行判断。\n    const targetType = getTargetType(target);\n    //当类型值判断出是不能代理的类型则直接返回\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    //进行target代理操作\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\n\n//1.进入判断如果value有__v_skip属性且为true或对象是可拓展则返回0，否则走类型判断函数\nfunction getTargetType(value) {\n//Object.isExtensible() 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap(toRawType(value));\n}\n//2.这里通过Object.prototype.toString.call(obj)来判断数据类型\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst toTypeString = (value) => objectToString.call(value);\n//3.这里rawType是为'Object'所以会返回1\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;//返回0说明除前面的类型外其他都不能被代理，如Date，RegExp，Promise等\n    }\n}\n")])])]),t("h3",{attrs:{id:"基本指令v-focus"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本指令v-focus"}},[e._v("#")]),e._v(" 基本指令v-focus")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("input组件初始化渲染时聚焦 \n<script setup>\n// 在模板中启用 v-focus\nconst vFocus = {\n  mounted: (el) => el.focus()\n}\n<\/script>\n\n<template>\n  <input v-focus />\n</template>\n\n指令钩子\nconst myDirective = {\n  // 在绑定元素的 attribute 前\n  // 或事件监听器应用前调用\n  created(el, binding, vnode, prevVnode) {\n    // 下面会介绍各个参数的细节\n  },\n  // 在元素被插入到 DOM 前调用\n  beforeMount(el, binding, vnode, prevVnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都挂载完成后调用\n  mounted(el, binding, vnode, prevVnode) {},\n  // 绑定元素的父组件更新前调用\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都更新后调用\n  updated(el, binding, vnode, prevVnode) {},\n  // 绑定元素的父组件卸载前调用\n  beforeUnmount(el, binding, vnode, prevVnode) {},\n  // 绑定元素的父组件卸载后调用\n  unmounted(el, binding, vnode, prevVnode) {}\n}\n")])])]),t("h3",{attrs:{id:"封装一个节流指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装一个节流指令"}},[e._v("#")]),e._v(" 封装一个节流指令")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/*\n  需求：防止按钮在短时间内被多次点击，使用节流函数限制规定时间内只能点击一次。\n\n  思路：\n    1、第一次点击，立即调用方法并禁用按钮，等延迟结束再次激活按钮\n    2、将需要触发的方法绑定在指令上\n  \n  使用：给 Dom 加上 v-throttle 及回调函数即可\n  <button v-throttle="debounceClick">节流提交</button>\n  因为用了el.disabled也就是dom元素的disabled的属性，没disabled属性得使用，是不生效得\n*/\nimport type { Directive, DirectiveBinding } from "vue";\ninterface ElType extends HTMLElement {\n\t__handleClick__: () => any;\n\tdisabled: boolean;\n}\nconst throttle: Directive = {\n\tmounted(el: ElType, binding: DirectiveBinding) {\n\t\tif (typeof binding.value !== "function") {\n\t\t\tthrow "callback must be a function";\n\t\t}\n\t\tlet timer: NodeJS.Timeout | null = null;\n\t\tel.__handleClick__ = function () {\n\t\t\tif (timer) {\n\t\t\t\tclearTimeout(timer);\n\t\t\t}\n\t\t\tif (!el.disabled) {\n\t\t\t\tel.disabled = true;\n\t\t\t\tbinding.value();\n\t\t\t\ttimer = setTimeout(() => {\n\t\t\t\t\tel.disabled = false;\n\t\t\t\t}, 1000);\n\t\t\t}\n\t\t};\n\t\tel.addEventListener("click", el.__handleClick__);\n\t},\n\tbeforeUnmount(el: ElType) {\n\t\tel.removeEventListener("click", el.__handleClick__);\n\t}\n};\nexport default throttle;\n')])])]),t("h3",{attrs:{id:"自定义hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义hooks"}},[e._v("#")]),e._v(" 自定义hooks")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import {ref,watch} from 'vue';\nexport function useSub({num1,num2}){\n    const subNum = ref(0);\n    watch([num1,num2],([num1,num2]) =>{\n        subFn(num1,num2)\n    })\n    const subFn = (num1,num2) =>{\n        subNum.value = num1 - num2\n    }\n    return {\n        subNum,\n        subFn\n    }\n}\n")])])]),t("h3",{attrs:{id:"vue-ssr-实现过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-ssr-实现过程"}},[e._v("#")]),e._v(" vue SSR 实现过程")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("创建工程 vue cli 3.0\nvue create ssr\n安装依赖\n渲染器 vue-server-renderer\nnodejs 服务器 express\n根目录下创建 server 文件夹 index.js文件\nindex.js index.js 中写Node 写页面内容\n\n")])])]),t("h3",{attrs:{id:"ssr由来"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssr由来"}},[e._v("#")]),e._v(" SSR由来")]),e._v(" "),t("p",[e._v("web1.0 服务端渲染 后端返回渲染后的页面给浏览器 --- nodejs时期 客户端渲染(客户端 url -- web server -- 返回html js 脚本 -- 浏览器执行js 脚本 -- java服务器 --- 查询mysql---返回浏览器数据 --浏览器渲染) --- SSR 服务端渲染(客户端url -- web server node服务器 --根据客户请求的url 执行对应页面并且向后端请求数据，并且根据返回的数据组装html --返回给客户端 --- 渲染页面 --- 向前端服务器请求javascript 脚本 --- 浏览器执行返回脚本---执行javascript 脚本 绑定动态事件 --- 调用后台接口 并且查询数据 返回数据 动态渲染页面---绑定事件--- )")]),e._v(" "),t("h2",{attrs:{id:"vue-router"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[e._v("#")]),e._v(" vue-router")]),e._v(" "),t("h3",{attrs:{id:"params-和-query-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#params-和-query-的区别"}},[e._v("#")]),e._v(" params 和 query 的区别")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("1. query 可以使用name 或者path 方式跳转\n//query传参，使用name跳转\nthis.$router.push({\n    name:'second',\n    query: {\n        queryId:'20180822',\n        queryName: 'query'\n    }\n})\n\n//query传参，使用path跳转\nthis.$router.push({\n    path:'second',\n    query: {\n        queryId:'20180822',\n        queryName: 'query'\n    }\n})\n\n//query传参接收\nthis.queryName = this.$route.query.queryName;\nthis.queryId = this.$route.query.queryId;\n\nparams只能使用name方式进行跳转引入\n//params传参 使用name\nthis.$router.push({\n  name:'second',\n  params: {\n    id:'20180822',\n     name: 'query'\n  }\n})\n\n//params接收参数\nthis.id = this.$route.params.id ;\nthis.name = this.$route.params.name ;\n\n2. 浏览器url 显示不同\nparams localhost:8080/second/1245314/wendy 页面刷新数据不丢失\nquery  localhost:8080?queryId='20180822'&queryName='query'  \n")])])]),t("h3",{attrs:{id:"手写vue-router"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手写vue-router"}},[e._v("#")]),e._v(" 手写vue-router")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/****** myVueRouter ******/\nlet vue = null;\nclass HistoryRoute {\n    constructor(){\n        this.current = null;\n    }\n}\nclass VueRouter{\n    constructor(options){\n        this.mode = options.mode || 'hash';\n        this.routes = options.routes || [];\n        this.routesMap = this.createMap(this.routes);\n        this.history = new HistoryRoute();\n        this.init()\n    }\n    init(){\n        if(this.mode == 'hash'){\n            location.hash ? '':(location.hash = '/');\n            window.addEventListener('load', () => {\n                // /home location.hash\n\t\t\t\tthis.history.current = location.hash.slice(1); \n\t\t\t});\n\t\t\twindow.addEventListener('hashchange', () => {\n                 // /home location.hash\n\t\t\t\tthis.history.current = location.hash.slice(1);\n\t\t\t});\n        }else{\n            location.pathname ? '' : (location.pathname = '/');\n            window.addEventListener('load',()=>{\n                this.history.current = location.pathname;\n                \n            })\n            window.addEventListener('popstate',()=>{\n                this.history.current = location.pathname;\n            })\n        } \n    }\n    //传入routes 返回 /home:{compoent:home,name:home}的对象\n    createMap(routes){\n        return routes.reduce((pre,current)=>{\n            pre[current.path] = current.component;\n            return pre;\n        },{})\n    }\n}\n//组件全局注册在vue上\nVueRouter.install = function(v){\n    vue = v;\n    vue.mixin({\n        beforeCreate(){\n            if(this.$options && this.$options.router){\n                如果是根组件\n                this._root = this;\n                this._router = this.$options.router;\n                Vue.util.defineRective(thid.'xxx',this._router.history);\n            }else{\n                this._root = this.$parent && this.$parent._root;\n            }\n            Object.defineProperty(this , '$router' ,{\n                get(){\n                    return this._root._router;\n                }\n            })\n            Object.defineProperty(this , '$route' ,{\n                get(){\n                    return this._root._router.history.current;\n                }\n            })\n\n        }\n    });\n    vue.component('router-link',{\n        props:{\n            to:string,\n        },\n        render(h){\n            let mode = this._self._root._router.mode\n            let to = mode === 'hash' ? '#' + this.to : this.to;\n            return h('a',{attrs:{herf:to}}, this.$slots.default);\n        }\n    })\n    //组件全局注册在vue上\n    vue.component('router-view',{\n        render(h){\n            let current = this._self._root._router.history.current;\n            let routeMap = this._self._root._router.routesMap;\n            return h(routeMap(current))\n        }\n    })\n}\n\n/**************index.js******************/\nimport VueRouter from './myVueRouter';\nVue.use(VueRouter)\nconst routes=[\n    {\n        path:'/home',\n        name:'Home',\n        component:Home\n    },\n    {\n        path:'/about',\n        name:'About',\n        component:About\n    }\n]\nconst router = new VueRouter({\n    mode:'hash',\n    routes\n})\nexport default router;\n")])])]),t("p",[e._v("声明vue-router 中 meta 中的数据类型")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("declare module 'vue-router'{\n    interface RouteMeta{\n        title:string;\n    }\n}\nrouter.js\nmeta:{\n    title:\"登录页面\"\n}\nmain.js\nrouter.beforeEach((to, from, next) => {\n    document.title = to.meta.title; \n})\n")])])]),t("p",[e._v("vue-router 过渡动画:子组件必须包含到一个root")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import \'animate.css\';\n<template>\n  <router-view #default="{Component}">\n    <transition  :enter-active-class="`animate__animated animate__bounceIn`">\n        <component :is="Component"></component>\n    </transition>\n </router-view>\n</template>\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);