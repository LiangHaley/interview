(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{426:function(e,t,r){"use strict";r.r(t);var n=r(1),a=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2"}},[e._v("#")]),e._v(" vue2")]),e._v(" "),t("h3",{attrs:{id:"vuex和minxin-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex和minxin-区别"}},[e._v("#")]),e._v(" vuex和minxin 区别？")]),e._v(" "),t("ol",[t("li",[e._v("vuex 抽离公共状态管理，vuex如果有一个组件改变数据，其他引入的部分也会改变")]),e._v(" "),t("li",[e._v("mixin数据方法都是独立的，组件间互不影响。")])]),e._v(" "),t("h3",{attrs:{id:"ssr、ssg、csr-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ssr、ssg、csr-的区别"}},[e._v("#")]),e._v(" SSR、SSG、CSR 的区别？")]),e._v(" "),t("p",[e._v("SSR:传统的渲染方式，由服务端把渲染的完整HTML页面吐给客户端，这样减少了客户端到服务端的http请求，加快响应速度，一般用于首屏优化。利于SEO 搭建 Nuxt/Quasar/Vite SSR\nSSG:是静态站点的生成，解析是在构建时执行，当发出请求时，html将静态存储，直接发送给客户端。\nCSR:客户端渲染")]),e._v(" "),t("h3",{attrs:{id:"vue-router-query-params-传参的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-query-params-传参的区别"}},[e._v("#")]),e._v(" vue-router query params 传参的区别")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("query 传参配置的是path ,而params 传参配置的是name\nrouter-link :to={path:\"/A/C\"} path 完整路径  \nconst route = useRoute(); route.push({path:\"/C\"}) 编程式导航只传入对应path\n  命名视图: \n      components: {\n        default: Home,\n        // LeftSidebar: LeftSidebar 的缩写\n        LeftSidebar,\n        // 它们与 `<router-view>` 上的 `name` 属性匹配\n        RightSidebar,\n      },\n      使用 父级 <router-view />\n               <router-view name = \"LeftSidebar\"/> \n               <router-view name = \"RightSidebar\"/>\n  重定向：\n    redirect: to => {\n      // 方法接收目标路由作为参数\n      // return 重定向的字符串路径/路径对象\n      return { path: '/search', query: { q: to.params.searchText } }\n    },\n    子路由中可获取到传递的query 参数\n    alias:['/A','/AD','/AS'] 路由别名\n\n")])])]),t("p",[e._v("vue3 使用 element-plus ，需单独引入css"),t("br"),e._v('\nimport ElementPlus from \'element-plus\';\nimport "/node_modules/element-plus/dist/index.css"\nvue2 使用elmentui\nscript setup 使用组合式api\nscript setup lang="ts"  组合式api ts写法')]),e._v(" "),t("h3",{attrs:{id:"vue-router-有几种路由模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-有几种路由模式"}},[e._v("#")]),e._v(" vue-router 有几种路由模式？")]),e._v(" "),t("p",[e._v("hash history\nhash 监听：hashchange load\nhistory:load popstate")]),e._v(" "),t("h3",{attrs:{id:"vue2-不能检测数组和对象的变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-不能检测数组和对象的变化"}},[e._v("#")]),e._v(" Vue2 不能检测数组和对象的变化")]),e._v(" "),t("p",[e._v("vue2监听是通过object.definePropety ，通过循环data 对象进行数据的监听更新\nvue3 通过proxy 实现数据监听，可监听数组对象的变化")]),e._v(" "),t("h3",{attrs:{id:"async语法与promise有什么区别联系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async语法与promise有什么区别联系"}},[e._v("#")]),e._v(" Async语法与Promise有什么区别联系？")]),e._v(" "),t("p",[e._v("axios 是由promise 实现异步请求调用的封装。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Async 是promise 的语法糖，将异步操作改成同步\npromise 解决函数回调地狱的问题\n致因：B需要A函数返回的参数，C需要B函数返回的参数，D需要C 函数返回的参数，形成了回调地狱\najax1(url, () => {\n    ajax2(url, () => {\n        ajax3(url, () => {\n        doSomething()\n        })\n    })\n})\n解决方式promise封装函数形成链式回调 A.then 里调用B函数传递A res，return B resultB .then 获取B resB 调用C(resB)形成链式回调\nfunction eat1(){\n    return new Promise((resolve, reject) => {\n        resolve('俺吃好啦,给你盘子')\n    })\n}\n\neat1().then( res => {\n    //吃完后给你再洗盘子\n    let result = res + '1111'\n    console.log(res,'111')\n    return result;\n}).then(res => {\n    //洗完盘子后，你妈妈甚至还奖励你吃冰淇淋！\n   console.log(res,'222')\n})\npromise 三种状态Pending, fullfilled rejected 一旦启动不可终止\npromise.all([p1,p2]).then((res)=>{\n  console.log(res) ==>p1 p2\n})\n一个报错全部报错\npromise.race([p1,p2]).then(res=>{\n  console.log(res)===>race 是容错机制判断 一个正确返回则代表正常\n})\n浏览器 多进程 --- 1个进程多个线程(JS引擎,GUI渲染，浏览器事件) ----JS单线程 同步执行IO阻塞（宏任务，微任务） --- promise 实现异步操作避免回调地狱.then.then 的方式 ----promise.all 接收多个同步返回数据 promise.race 容错判断机制\n")])])]),t("h3",{attrs:{id:"说说闭包的作用和坑"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说闭包的作用和坑"}},[e._v("#")]),e._v(" 说说闭包的作用和坑？")]),e._v(" "),t("p",[e._v("控制访问  函数柯里化")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1)(2) ); // 3\n")])])]),t("h3",{attrs:{id:"说说你对javascript-执行过程的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说你对javascript-执行过程的理解"}},[e._v("#")]),e._v(" 说说你对Javascript 执行过程的理解？")]),e._v(" "),t("p",[e._v("javascript 执行过程主要分为两个阶段：编译阶段和执行阶段\n编译阶段JS引擎主要做三件事： 词法分析 --- 语法分析AST -- new AST代码生成。\n编译完成后JS引擎开始创建执行上下文(javascript代码运行环境)，并运行JS代码。")]),e._v(" "),t("h3",{attrs:{id:"prototype-和-proto-是什么-instanceof原理是"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prototype-和-proto-是什么-instanceof原理是"}},[e._v("#")]),e._v(" prototype 和_proto_是什么？instanceOf原理是？")]),e._v(" "),t("p",[e._v('对象有属性__proto__,指向该对象的构造函数的原型对象。\n方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。\nfunction GirlFriend () {\nthis.name = "Alice";\n}\nvar hand = {\nwhichOne: "right hand",\nsomeFunction: function(){\nconsole.log("not safe for work.");\n}\n};\nGirlFriend.prototype = hand;\nvar myObject = new GirlFriend();\nconsole.log(myObject.'),t("strong",[e._v("proto")]),e._v(" === GirlFriend.prototype)\n每个实例对象(object)都有一个私有属性(称之为_proto_)指向他的构造函数的原型对象prototype，该原型对象也有一个自己的原型对象（"),t("strong",[e._v("proto")]),e._v("），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。\n获取原型的方法已经不推荐使用_proto_,推荐使用Object.getPrototypeOf()/Reflect.getPrototypeof() 和 Object.setPrototypeOf()/Reflect.setPrototypeOf()\ninstanceof 可判断所有数据类型\ntypeof\n判断基本数据类型除了值为null 以外均可以返回正确的结果\n判断引用数据类型，除了function以外，一律返回object类型\n对于Null,返回object类型\n对于function,返回function类型")]),e._v(" "),t("h3",{attrs:{id:"什么是js事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是js事件循环"}},[e._v("#")]),e._v(" 什么是js事件循环？")]),e._v(" "),t("p",[e._v("js中的eventloop：\n所有的同步任务都是在主线程里执行的，异步任务可能会在macrotask或者microtask里面\n同步任务:主线程上排队执行的任务，只有前一个任务执行完才能执行下一个\n异步任务：不进入主线程，某个异步任务可以执行了完结果返回给同步任务\n微任务：prmise async await process.nextTick(node) mutationObserver(html5特性)\n宏任务：script(整体代码) setTimeout setInterval setImmediate I/O UI render\n大致流程：主线程---微任务---宏任务--宏任务中的微任务--宏任务中微任务中的宏任务")]),e._v(" "),t("h3",{attrs:{id:"js-加载执行-async-defer-preload-prefetch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-加载执行-async-defer-preload-prefetch的区别"}},[e._v("#")]),e._v(" js 加载执行 async defer preload prefetch的区别？")]),e._v(" "),t("p",[e._v("prefetch:多用于预解析dns的域名\npreload：预加载，存放于内存中，不会执行其中的js语句，只有当遇到js的时候浏览器才会将预加载的js解执行掉\nasync：异步执行加载一些无依赖的代码。比如Google Analysis之类。\ndefer：执行时间是所有dom元素解析完成之后，DOMContentLoaded 事件触发之前")]),e._v(" "),t("h3",{attrs:{id:"bear-强缓存-协商缓存-cdn缓存区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bear-强缓存-协商缓存-cdn缓存区别"}},[e._v("#")]),e._v(" :bear 强缓存 协商缓存 cdn缓存区别？")]),e._v(" "),t("p",[e._v("cdn缓存：顾名思义内容缓存在cdn 上，要是负载均衡到其他服务器，也会溯源去查上级服务器是否有缓存\n强缓存：利用expires或者cache-control这两个http header实现的，表示资源在客户端的有效期。\n协商缓存：如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。使用协商缓存策略，会先向服务器发送一个请求，如果资源没有发生更改返回304，让客户端使用本地的缓存，如果资源发生修改则返回修改后的资源。")]),e._v(" "),t("h3",{attrs:{id:"构造器创建对象与class有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造器创建对象与class有什么区别"}},[e._v("#")]),e._v(" 构造器创建对象与class有什么区别？")]),e._v(" "),t("h3",{attrs:{id:"vue2-和-vue3-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-的区别"}},[e._v("#")]),e._v(" vue2 和 vue3 的区别？")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vue2 Options Api 虽然有mixin 但是命名冲突\nvue3 composition Api 解决options api在大型项目中，options api不好拆分和重用的问题\nProxy 相对于 Object.defineProperty\nproxy 性能本身就比Object.defineProperty好，proxy可以拦截属性的访问、赋值、删除等操作，每一次都是new proxy 创建一个新的空间。\nvue3 proxy reflect  get set deleteProperty 获取 赋值 拦截删除属性 \nvue2 for循环遍历object.definePropety getter setter 设置获取数据 不可进行删除操作\nVue 3.0 性能提升主要是通过哪几方面体现的？\n1) 响应式系统提升：监听动态新增的属性 监听删除的属性 监听数组的索引和 length 属性\n2) 优化编译和重写虚拟dom,vue2通过标记静态根节点，优化diff算法，vue3标记提升所有静态根节点，diff只比较动态内容。\n3）静态提升：patch flag, 跳过静态节点,直接对比动态节点,缓存事件处理函数\n4）源码体积优化：tree shaking 移除了一些不常用的api inline-template filter\n5) 编译优化：\n  a. 生成 Block tree:vue2 数据更新触发的重新渲染粒度是组件级的，vue3 只更新动态数据变化部分\n  b. slot 编译优化: vue2 如果一个组件传入了slot,每次父组件更新的时候，会强制使子组件更新，造成性能浪费。vue3 优化了slot的生成，使得非动态slot中属性的更新只会触发子组件的更新。\n6）响应式系统的实现原理 \n  a. reactive:设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。创建拦截器handerler，设置get/set/deleteproperty。\n  b. get:收集依赖如果当前 key 的值是对象，则为当前 key 的对象创建拦截器 handler, 设置 get/set/deleteProperty；如果当前的 key 的值不是对象，则返回当前 key 的值。\n  c. 设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。deleteProperty 当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。\n  d. effect 接收一个函数作为参数\n  e. track 接收两个参数：target 和 key\n  f: trigger 判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。\n")])])]),t("h3",{attrs:{id:"webpack相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack相关"}},[e._v("#")]),e._v(" Webpack相关")]),e._v(" "),t("p",[e._v("webpack的工作原理：分析项目结构,找到javascript 模块以及其他一些浏览器不能直接运行的拓展语言(sass,typeScript等),并将其转换和打包为适合的格式提供给浏览器使用，3.0,webpack 还肩负起优化的责任。\nwebpack的构建流程：\n初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。\n开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。\n确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。\n编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。\n完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；\n输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；7.输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统\nwebpack基本功能：\n代码转换 typescript转javascript scss转css\n文件优化 压缩javascript css html代码，压缩合并图片等\n代码分割 提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载\n模块合并 在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件\n自动刷新 监听本地源代码的变化自动构建，刷新浏览器\n代码校验 检查代码是否符合规范\n自动发布 更新代码后，自动构建出线上发布代码并传输给发布系统。\n前端为什么要进行打包构建：\n体积更小，加载更快\n编译高级语言和语法\n兼容性和错误检查\n研发层面：统一 高效的开发环境 统一的构建流程和产出标准 集成公司构建规范\nwebpack 配置方面的区别？\npackage.json --- script 查看命令所需的脚本文件路径 --- 找到dev.serve.js / build.js(不同环境配置不同的内容，动态添加 NODE_ENV 变量) --- 找到对应的webpack.config.js --- dev 不配置minicss plugins prod 不会有HtmlWebpackPlugin HotModuleReplacementPlugin plugins --- 最终代码打包压缩/构建\nES7:includes\nES8: padStart pardEnd / Object.entries Object.values / Object.getOwnPropertyDescriptors / Async functions / Trailing commas\nES9: Async iterators / promise.prototype.finally\nES10: ??(空值合并操作符,左侧为undefined null 返回右侧值) ||(逻辑或操作符,左侧为假返回右侧) ?.(可选链操作符,允许读取位于链接对象深处的值，不可用于赋值) globalThis(获取全局对象，是window,this,nodejs->global的综合) import按需导入\nES11:\nES12: &&= ||= ??= replaceAll() Promise.any(接收一组promise实例做为参数，包装成一个新的promise实例返回，只返回第一返回的值)")]),e._v(" "),t("h3",{attrs:{id:"promise-all-promise-race-promise-any-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-all-promise-race-promise-any-区别"}},[e._v("#")]),e._v(" promise.all promise.race promise.any 区别？")]),e._v(" "),t("p",[e._v("promise.all:一个失败全部失败 返回一个数组\npromise.race: 第一个异步返回值成功则代表所有成功，失败则全部失败\npromise.any : 找到第一个异步返回成功的值，如果全部都被拒绝则返回包含原因数组的AggregateError")]),e._v(" "),t("h3",{attrs:{id:"entry-runtime-with-compiler-vue-prototype-mount-和-runtime-index-vue-prototype-mount-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#entry-runtime-with-compiler-vue-prototype-mount-和-runtime-index-vue-prototype-mount-区别"}},[e._v("#")]),e._v(" entry-runtime-with-compiler  Vue.prototype.$mount  和 ./runtime/index  Vue.prototype.$mount 区别？")]),e._v(" "),t("h3",{attrs:{id:"vue源码调试具体步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码调试具体步骤"}},[e._v("#")]),e._v(" vue源码调试"),t("a",{attrs:{href:"https://juejin.cn/post/7142771584267681829",target:"_blank",rel:"noopener noreferrer"}},[e._v("具体步骤"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"源码调试vscode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码调试vscode"}},[e._v("#")]),e._v(" 源码调试"),t("a",{attrs:{href:"https://www.cnblogs.com/elmluo/p/14783093.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("vscode"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"vue2-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-2"}},[e._v("#")]),e._v(" vue2")]),e._v(" "),t("h3",{attrs:{id:"vue2-对象对象劫持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-对象对象劫持"}},[e._v("#")]),e._v(" vue2 对象对象劫持？")]),e._v(" "),t("p",[e._v("observe -- new Observe --- walk处理对象 --- for循环 defineReactive（obj,keys） --- defineReactive")]),e._v(" "),t("h3",{attrs:{id:"vue2-数组劫持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-数组劫持"}},[e._v("#")]),e._v(" vue2 数组劫持？")]),e._v(" "),t("p",[e._v("方法:函数劫持，重新创建数组方法\n数组{list:[1,2,3,4],arr:[{a:1}]}")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * Define a property.\n *  value  key:push  src[key] push= >metor 函数\n */\nexport function def (obj: Object, key: string, val: any, enumerable?: boolean) {\n  Object.defineProperty(obj, key, {\n    value: val, //ƒ ()\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  })\n}\n")])])]),t("p",[e._v("jsonShcema")]),e._v(" "),t("Vssue")],1)}),[],!1,null,null,null);t.default=a.exports}}]);