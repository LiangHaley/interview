(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{431:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h1",{attrs:{id:"js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[this._v("#")]),this._v(" js")]),this._v(" "),t("h2",{attrs:{id:"this指向"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[this._v("#")]),this._v(" this指向")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("new实例化 > 显示 > 隐式 > 默认\n箭头函数：1）可以解决this指向问题 2）页面看起来更简洁 \n构造器中this指向new 关键字调用,对象调用 this指向调用它的对象\ncall :  原来 let agrs = Array.prototype.slice.call(arguments) 将类数组转化为数组  ES6新增 Array.form(arguments)\nthis 指向方式总结：\n    1）默认绑定 全局 window  \n    2）隐式绑定 取决上下文环境 \n    3）显示绑定 通过call aplly bind改变this指向 \n    4）构造函数中指向new 实例 \n    5）setTimout 传入了匿名函数，和全局执行函数相同 解决方式是：把function改为无独立上下文的箭头函数即可解决\n")])])]),t("Vssue")],1)}),[],!1,null,null,null);s.default=e.exports}}]);