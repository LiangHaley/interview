(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{432:function(n,e,t){"use strict";t.r(e);var i=t(1),a=Object(i.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("本文主要记录vue2 相关插件的学习内容")]),n._v(" "),e("h2",{attrs:{id:"vue2的高级用法-组合式api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2的高级用法-组合式api"}},[n._v("#")]),n._v(" vue2的高级用法 组合式api")]),n._v(" "),e("p",[n._v("package.json ---- scripts/config.js (full-dev)----src/platforms/web---entry-runtime-with-compiler.ts --- ./runtime-with-compiler---./runtime/index ---core/index---./instance/index\nvue 源码解读：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  compiler: 编译模块，AST核心\n  core: Api核心\n  platform:虚拟dom 生成weex web 能识别的语言\n  server 服务端渲染\n")])])]),e("h3",{attrs:{id:"指令特殊项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#指令特殊项"}},[n._v("#")]),n._v(" 指令特殊项")]),n._v(" "),e("p",[n._v("v-if v-for 不能同时用\nv-for 搭配 in of用")]),n._v(" "),e("h3",{attrs:{id:"mixin"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mixin"}},[n._v("#")]),n._v(" mixin")]),n._v(" "),e("p",[n._v("局部引入mixin:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("新建一个mixin 文件夹，包含index.js文件\n// 定义一个混入对象\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n//引入index.js在子组件中\n// 定义一个使用混入对象的组件\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // => \"hello from mixin!\" \n")])])]),e("p",[n._v("全局引入mixin:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 为自定义的选项 'myOption' 注入一个处理器。\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// => \"hello!\"\n")])])]),e("p",[n._v("mixin 优先级 > 组件函数，而且会同步执行，当mixin内容和components内容重复的时候会执行两遍，参数调用的是组件内部的。")]),n._v(" "),e("h3",{attrs:{id:"自定义指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[n._v("#")]),n._v(" 自定义指令")]),n._v(" "),e("p",[n._v("指令的声明周期\nbind:(el,binding,vnode,oldVnode) 这个函数只调用一次，就是绑定元素的时候 el dom 元素 binding 绑定一些参数 vnode 虚拟dom oldVode 上一个虚拟节点 仅在update 和componentUpdated钩子中可用\ninserted 被绑定元素 插入父元素时调用该函数\nupdate 所在组件的Vnode 更新时调用\ncomponentUpdated 指令所在的组件的 vnode 及其 子组件的 vnode 全部更新之后调用\nunbind 指令与元素解绑时调用")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(' 第一种：直接在 directives 中书写自定义指令\n  <input type="text" v-default-value="val">\n  export default {\n    // 自定义指令\n    directives: {\n      defaultValue: function (el, binding) {\n        console.log(binding);\n        el.value = binding.value   //  binding.value 的值  保存的是指令的 等号 后面的属性值\n      }\n    }\n  }\n  第二种：指令书写在单独的js文件中\n  // focus.js\n  export default {\n      // 被绑定元素插入父节点的调用\n      inserted(el) {\n          el.focus()\n      },\n  }\n  //调用指令位置\n  import focus from "@/utils/directives/focus";\n  directives: {\n      focus,\n    }\n  用户名: <input v-focus type="text">\n\n第三种：动态指令参数\n  export default {\n      bind(el, binding) {\n          console.log(binding);\n          el.style[binding.arg] = binding.value + "px"\n      }\n  }\n  import fixed from "@/utils/directives/fixed";\n   directives: {\n      fixed,\n    }\n    data() {\n      return {\n        direction: \'right\',\n      }\n    },\n  <div v-fixed:[direction]="300" class="box"></div>\n\n第四种:全局指令\n  main.js\n  Vue.directive("font-color", {\n    bind(el, binding) {\n      el.style.color = binding.value\n    }\n  })\n  data() {\n    return {\n      colorVal: \'#00ff00\'\n    };\n  }\n  <div v-font-color="colorVal">\n    文字文字\n  </div>\n')])])]),e("p",[n._v("v-model 源码解析  v-bind @input")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<input type="text" :value="username" @input="username = $event.target.value" />\n通过v-bind:value 绑定username变量 每次输入触发Input事件\n通过事件对象参数 event.target.value 获得输入的内容，并且把这个内容赋值给username\n此时更新username 值时input框会发生变化 更改input框时username 值会发生变化 实现双向数据绑定\n')])])]),e("p",[n._v("原生实现v-mode")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" <div id=\"#app\">\n        姓名:<input type = \"text\" v-model=\"name\">\n    </div>\n    <script>\n        class vue {\n            constructor({el,data}){\n                console.log(el,data)\n                this.el = document.getElementById(el);\n                console.log(this.el)\n                this.data =data;\n                this.initData();\n                this.initMode()\n            }\n            initData(){\n                Object.entries(this.data).forEach(([key,value])=>{\n                    let val = value;\n                    Object.defineProperty(this,key,{\n                        get(){\n                            return val\n                        },\n                        set(newVal){\n                            val =newVal\n                        }\n                    })\n                })\n            }\n            initMode(){\n                console.log(this.el)\n                const nodes = this.el.querySelectorAll('[v-model]');\n                \n                nodes.forEach(item =>{\n                    let key = item.getAttribute('v-model');\n                    item.value = this[key];\n                    item.addEventListener('input',e=>{\n                        this[key]=e.target.value;\n                    })\n                    console.log(key);\n                })\n            }\n        }\n     let vm = new vue({\n            el:\"#app\",\n            data:{\n                name:'huanhuan'\n            }\n        })\n    <\/script>\n")])])]),e("h3",{attrs:{id:"vue-源码解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码解析"}},[n._v("#")]),n._v(" Vue 源码解析")]),n._v(" "),e("p",[n._v("flow: 类型推断 类型注释\nrollup 进行打包构建\nvue2 用原型注入\n编译：将源代码转换为可执行的程序或库的过程，会经历词法分析 -- 语法分析 -- 语义分析 -- 代码生成等\n构建：是指将多个编译后的文件组合成一个可以部署的软件包的过程。这个软件包含可执行文件、库文件、配置文件、文档、资源文件。\n运行: 实际调用编译的渲染函数，称之为运行过程。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("vue 项目中 import vue from vue 则是引入 entry-runtime-with-compiler.js\n构建vue项目:\n entry-runtime.js时 需要借助webpack vue-loader 进行编译\n entry-runtime-with-compiler.js 运行+编译\n \nvue源码解析 --- package.json --- scripts / build.js --- scripts/config.js --- (entry-runtime.js/entry-runtime-with-compiler.js) --- ./runtime/index --- core/index --- \n")])])]),e("Vssue")],1)}),[],!1,null,null,null);e.default=a.exports}}]);